// --------------------------------------------------------
// Copyright (c)
//
// contributions by author
//                  author@somewhere.net
// maintained by    maintainer
//                  maintainer@somewhere.net

// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#ifndef ANCHORING_PROCESS_DEF_ANCHORING_PROCESS_IMPL_H
#define ANCHORING_PROCESS_DEF_ANCHORING_PROCESS_IMPL_H

/************************************************************
 anchoring_process_impl class header
 ************************************************************/

#include "anchoring_process_def/Pkg_anchoring_process_def.h"

#include "anchoring_process_def/anchoring_process.h"

#include "typedb_client.hpp"

#include <fstream>
#include <stdexcept>
#include <nlohmann/json.hpp>
#include <pluginlib/class_loader.hpp>
#include <anchoring_core/anchoring_manager.hpp>

namespace ros2Library {
namespace rclcpp {
class NodeOptions;
}
}
namespace ros2Library {
namespace rclcpp_action {
class CancelResponse;
}
}
namespace ros2Library {
namespace rclcpp_action {
class GoalResponse;
}
}
namespace ros2Library {
namespace rclcpp_action {
class GoalUUID;
}
}

using json = nlohmann::json;

/// Represents one DT_config entry retrieved from TypeDB.
struct DTConfig {
    std::string cls;
    std::string dtId;
    std::string platform;
    std::string parentInstanceId;
};

class DTSimulator {
public:
    /**
     * Reads the specified JSON array file and returns the object
     * whose "dt_id" matches dtId.
     * @param dtId          The Digital Twin identifier to search for.
     * @param dataFilePath  Path to the JSON file containing DT records.
     * @return              A JSON object representing the matched DT record.
     */
    static json fetchDTData(const std::string &dtId,
                                      const std::string &dataFilePath) {
        std::ifstream in(dataFilePath);
        if (!in.is_open()) {
            throw std::runtime_error("DTSimulator: cannot open " + dataFilePath);
        }
        json arr;
        in >> arr;  // Parse the entire JSON array

        for (const auto &entry : arr) {
            if (entry.value("dt_id", "") == dtId) {
                return entry;
            }
        }
        throw std::runtime_error("DTSimulator: dt_id \"" + dtId + "\" not found");
    }
};

namespace anchoring_process_def {

/************************************************************/
/**
 * This is a skeleton class generated for component anchoring_process
 * Copy it into the source folder as an initial base (or copy parts
 * of it whenever you add modify the component).
 * 
 */
class anchoring_process_impl: public anchoring_process {
public:

  /**
   * 
   * @param options 
   */
  anchoring_process_impl(rclcpp::NodeOptions /*in*/options);

  /**
   *
   */
  ~anchoring_process_impl();

  /**
   *
   */
  rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
      on_configure(const rclcpp_lifecycle::State &) override;

  /**
   * 
   * @param uuid 
   * @param goal 
   * @return return 
   */
  rclcpp_action::GoalResponse set_ontology_goal(
      const rclcpp_action::GoalUUID & /*in*/uuid,
      std::shared_ptr<
          const anchoring_process_interfaces::action::SetOntology::Goal> /*in*/goal);

  /**
   * 
   * @param goal_handle 
   * @return return 
   */
  rclcpp_action::CancelResponse set_ontology_cancel(
      const std::shared_ptr<
          rclcpp_action::ServerGoalHandle<
              anchoring_process_interfaces::action::SetOntology>> /*in*/goal_handle);

  /**
   * 
   * @param goal_handle 
   */
  void set_ontology_accepted(
      const std::shared_ptr<
          rclcpp_action::ServerGoalHandle<
              anchoring_process_interfaces::action::SetOntology>> /*in*/goal_handle);

  /**
   * 
   * @param uuid 
   * @param goal 
   * @return return 
   */
  rclcpp_action::GoalResponse populate_instances_goal(
      const rclcpp_action::GoalUUID & /*in*/uuid,
      std::shared_ptr<
          const anchoring_process_interfaces::action::PopulateInstances::Goal> /*in*/goal);

  /**
   * 
   * @param goal_handle 
   * @return return 
   */
  rclcpp_action::CancelResponse populate_instances_cancel(
      const std::shared_ptr<
          rclcpp_action::ServerGoalHandle<
              anchoring_process_interfaces::action::PopulateInstances>> /*in*/goal_handle);

  /**
   * 
   * @param goal_handle 
   */
  void populate_instances_accepted(
      const std::shared_ptr<
          rclcpp_action::ServerGoalHandle<
              anchoring_process_interfaces::action::PopulateInstances>> /*in*/goal_handle);

  /**
   * 
   * @param uuid 
   * @param goal 
   * @return return 
   */
  rclcpp_action::GoalResponse update_state_goal(
      const rclcpp_action::GoalUUID & /*in*/uuid,
      std::shared_ptr<
          const anchoring_process_interfaces::action::UpdateState::Goal> /*in*/goal);

  /**
   * 
   * @param goal_handle 
   * @return return 
   */
  rclcpp_action::CancelResponse update_state_cancel(
      const std::shared_ptr<
          rclcpp_action::ServerGoalHandle<
              anchoring_process_interfaces::action::UpdateState>> /*in*/goal_handle);

  /**
   * 
   * @param goal_handle 
   */
  void update_state_accepted(
      const std::shared_ptr<
          rclcpp_action::ServerGoalHandle<
              anchoring_process_interfaces::action::UpdateState>> /*in*/goal_handle);

protected:

  /**
   *
   */
  bool loadAnchoringPlugins();

  /**
   *
   */
  bool findOntologySchemas();

  /**
   *
   */
  bool createOrReplaceDatabases();

//  std::string serverAddr_;
  std::unique_ptr<TypeDB::Driver> driver_;
//  std::string dbName_;

  // entity managers
  using ManagersMap = std::unordered_map<std::string, anchoring_core::AnchoringManager::Ptr>;
  ManagersMap managers_;
  pluginlib::ClassLoader<anchoring_core::AnchoringManager> am_loader_;

  // domain schemas
  using SchemasMap = std::unordered_map<std::string, std::vector<std::string>>;
  SchemasMap schemas_;

  // domain databases
  using DbNamesMap = std::unordered_map<std::string, std::string>;
  DbNamesMap databases_;

  // node params for entity managers
  std::vector<std::string> managers_ids_;
  std::vector<std::string> managers_types_;

  // node params for knowledge domains
  std::vector<std::string> domains_ids_;

};
/************************************************************/
/* External declarations (package visibility)               */
/************************************************************/

/* Inline functions                                         */

} // of namespace anchoring_process_def

/************************************************************
 End of anchoring_process_impl class header
 ************************************************************/

#endif
