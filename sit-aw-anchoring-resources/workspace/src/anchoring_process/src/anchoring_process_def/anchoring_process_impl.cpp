// --------------------------------------------------------
// Copyright (c)
//
// contributions by author
//                  author@somewhere.net
// maintained by    maintainer
//                  maintainer@somewhere.net

// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#define anchoring_process_def_anchoring_process_impl_BODY

/************************************************************
 anchoring_process_impl class body
 ************************************************************/

// include associated header file
#include "anchoring_process_def/anchoring_process_impl.h"

// Derived includes directives
#include "rclcpp/rclcpp.hpp"
#include "rclcpp_action/rclcpp_action.hpp"

namespace anchoring_process_def {

// static attributes (if any)

/**
 * 
 * @param options 
 */
anchoring_process_impl::anchoring_process_impl(rclcpp::NodeOptions /*in*/options) :
    anchoring_process(options),
    am_loader_("anchoring_core", "anchoring_core::AnchoringManager"){

    // declare parameters
    declare_parameter("typedb_server_addr", "localhost:1729");
    declare_parameter("entity_managers",    rclcpp::PARAMETER_STRING_ARRAY); // no default value
    declare_parameter("knowledge_domains",  rclcpp::PARAMETER_STRING_ARRAY); // no default value
}

/**
 * 
 * @param options 
 */
anchoring_process_impl::~anchoring_process_impl()
{
  managers_.clear();
  schemas_.clear();
  databases_.clear();
  driver_.reset(); 
}

/**
 *  
 */
rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
  anchoring_process_impl::on_configure(const rclcpp_lifecycle::State & state)
{
    // base implem.
    anchoring_process::on_configure(state);
 
    RCLCPP_INFO(get_logger(), "Configuring (impl)");
   
    auto node = shared_from_this();

    // get parameters
    // - typedb_server_addr
    std::string typedb_server_addr;
    get_parameter("typedb_server_addr", typedb_server_addr);
    driver_ = std::make_unique<TypeDB::Driver>(TypeDB::Driver::coreDriver(typedb_server_addr));
    // - ontology related params
    get_parameter("entity_managers", managers_ids_);
    get_parameter("knowledge_domains", domains_ids_);
    if (!loadAnchoringPlugins() || !findOntologySchemas() || !createOrReplaceDatabases()) {
        on_cleanup(state);
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::FAILURE;
    }

    return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
}

/**
 * 
 * @param uuid 
 * @param goal 
 * @return return 
 */
rclcpp_action::GoalResponse anchoring_process_impl::set_ontology_goal(
    const rclcpp_action::GoalUUID & /*in*/uuid,
    std::shared_ptr<
        const anchoring_process_interfaces::action::SetOntology::Goal> /*in*/goal) {

  RCLCPP_INFO(this->get_logger(), "[set_ontology] Got new goal request for domain %s (request uuid %s)", goal->knowledge_domain.c_str(), rclcpp_action::to_string(uuid).c_str());
  if (goal == nullptr)
      return rclcpp_action::GoalResponse::REJECT;
  // Check whether the knowledge domain is known
  auto it = schemas_.find(goal->knowledge_domain);
  if (it == schemas_.end()) {
      // knownledge domain is unknown, Reject
      RCLCPP_FATAL(this->get_logger(), "[set_ontology] Goal knowledge domain %s is unknown.", goal->knowledge_domain.c_str());
      return rclcpp_action::GoalResponse::REJECT;
  }
  // otherwise, knownledge domain is known.
  // TODO: Check database is still accessible
  // Accept
  return rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;

}

/**
 * 
 * @param goal_handle 
 * @return return 
 */
rclcpp_action::CancelResponse anchoring_process_impl::set_ontology_cancel(
    const std::shared_ptr<
        rclcpp_action::ServerGoalHandle<
            anchoring_process_interfaces::action::SetOntology>> /*in*/goal_handle) {

  RCLCPP_INFO(this->get_logger(), "[set_ontology] Got cancel request for goal %s.", rclcpp_action::to_string(goal_handle->get_goal_id()).c_str());
  return rclcpp_action::CancelResponse::ACCEPT;

}

/**
 * 
 * @param goal_handle 
 */
void anchoring_process_impl::set_ontology_accepted(
    const std::shared_ptr<
        rclcpp_action::ServerGoalHandle<
            anchoring_process_interfaces::action::SetOntology>> /*in*/goal_handle) {

    const auto goal = goal_handle->get_goal();

    RCLCPP_INFO(this->get_logger(), "[set_ontology] Executing request for domain %s (request uuid %s)", goal->knowledge_domain.c_str(), rclcpp_action::to_string(goal_handle->get_goal_id()).c_str());

    auto result = std::make_shared<anchoring_process_interfaces::action::SetOntology::Result>();
    result->result.success = false;
    result->result.message = "";

    // Get the database name for the domain
    std::string dbname = databases_.find(goal->knowledge_domain)->second;

    // Insert Schema
    // - setup
    std::vector<std::string> schemas = schemas_.find(goal->knowledge_domain)->second;
    std::ostringstream schema;
    //    process (read) each schema
    for (const std::string& s : schemas) {
      std::ifstream st(s);
      schema << st.rdbuf() << "\n";
    }
    // - write
    try
    {
      TypeDBClient::write_schema(schema.str(), driver_, dbname);
    }
    catch (const std::exception &e)
    {
      // terminate action (failure!)
      result->result.message = std::string(e.what());
      RCLCPP_FATAL(this->get_logger(), "[set_ontology] Unable to set the ontology in the database: %s", e.what());
      goal_handle->abort(result);
      return;
    }

    // terminate action (success!)
    RCLCPP_INFO(this->get_logger(), "[set_ontology] Request for goal %s executed successfully.", rclcpp_action::to_string(goal_handle->get_goal_id()).c_str());
    result->result.success = true;
    goal_handle->succeed(result);
}

/**
 * 
 * @param uuid 
 * @param goal 
 * @return return 
 */
rclcpp_action::GoalResponse anchoring_process_impl::populate_instances_goal(
    const rclcpp_action::GoalUUID & /*in*/uuid,
    std::shared_ptr<
        const anchoring_process_interfaces::action::PopulateInstances::Goal> /*in*/goal) {

  RCLCPP_INFO(this->get_logger(), "[populate_instances] Got new goal request for domain %s (request uuid %s)", goal->knowledge_domain.c_str(), rclcpp_action::to_string(uuid).c_str());
  if (goal == nullptr)
      return rclcpp_action::GoalResponse::REJECT;
  // Accept
  return rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;

}

/**
 * 
 * @param goal_handle 
 * @return return 
 */
rclcpp_action::CancelResponse anchoring_process_impl::populate_instances_cancel(
    const std::shared_ptr<
        rclcpp_action::ServerGoalHandle<
            anchoring_process_interfaces::action::PopulateInstances>> /*in*/goal_handle) {

  RCLCPP_INFO(this->get_logger(), "[populate_instances] Got cancel request for goal %s.", rclcpp_action::to_string(goal_handle->get_goal_id()).c_str());
  return rclcpp_action::CancelResponse::ACCEPT;

}

/**
 * 
 * @param goal_handle 
 */
void anchoring_process_impl::populate_instances_accepted(
    const std::shared_ptr<
        rclcpp_action::ServerGoalHandle<
            anchoring_process_interfaces::action::PopulateInstances>> /*in*/goal_handle) {

    const auto goal = goal_handle->get_goal();

    RCLCPP_INFO(this->get_logger(), "[populate_instances] Executing request for domain %s (request uuid %s)", goal->knowledge_domain.c_str(), rclcpp_action::to_string(goal_handle->get_goal_id()).c_str());

    auto result = std::make_shared<anchoring_process_interfaces::action::PopulateInstances::Result>();
    result->result.success = false;
    result->result.message = "";

    // Get the database name for the domain
    std::string dbname = databases_.find(goal->knowledge_domain)->second;

    // - setup
    std::ifstream f(goal->instances);
    if (!f.good())
    {
      result->result.message = "[populate_instances] Unable to access instances setup file at "
                                  + goal->instances;
      RCLCPP_FATAL(this->get_logger(), result->result.message.c_str());
      goal_handle->abort(result);
      return;
    }
    json data = json::parse(f);
    std::vector<std::string> queries;

    // process each element
    for (const json& e : data)
    {
        auto id   = e.value("id", "");
        auto name = e.value("name", "");
        auto cls  = e["setup_properties"].value("class", "");

        // insert instance
        std::string q = "insert $x isa " + cls +
                        ", has id \"" + id +
                        "\", has name \"" + name + "\";";
        queries.push_back(q);

        // entity-specific queries
        std::vector<std::string> cls_queries = managers_[cls]->generatePopulateInstanceQueries(e);
        queries.reserve(queries.size() + cls_queries.size());
        queries.insert(queries.end(), cls_queries.begin(), cls_queries.end());

        // add DT data
        if (e.contains("DT_config"))
        {   
          for (const auto &cfg : e["DT_config"])
          {
            std::string dtId     = cfg.value("id_DT", "");
            std::string platform = cfg.value("DigitalTwin", "");
            // Insert the DigitalTwin entity
            q = "insert $t isa DigitalTwin_ID, "
                "has dt-id \""     + dtId     +
                "\", has platform-name \"" + platform + "\";";
            queries.push_back(q);

            // Link asset and twin
            // We match both by their identifying attributes
            q = "match $a isa " + cls + ", has id \""   + id     + "\"; "
                "$t isa DigitalTwin_ID, has dt-id \"" + dtId + "\"; "
                "insert (asset: $a, twin: $t) isa has_id;";
            queries.push_back(q);
          }
        }
    }

    // - write
    TypeDBClient::insert_data(queries, driver_, dbname);


    // terminate action (success!)
    RCLCPP_INFO(this->get_logger(), "[populate_instances] Request for goal %s executed successfully.", rclcpp_action::to_string(goal_handle->get_goal_id()).c_str());
    result->result.success = true;
    goal_handle->succeed(result);
}

/**
 * 
 * @param uuid 
 * @param goal 
 * @return return 
 */
rclcpp_action::GoalResponse anchoring_process_impl::update_state_goal(
    const rclcpp_action::GoalUUID & /*in*/uuid,
    std::shared_ptr<
        const anchoring_process_interfaces::action::UpdateState::Goal> /*in*/goal) {

  RCLCPP_INFO(this->get_logger(), "[update_state] Got new goal request for domain %s (request uuid %s)", goal->knowledge_domain.c_str(), rclcpp_action::to_string(uuid).c_str());
  if (goal == nullptr)
      return rclcpp_action::GoalResponse::REJECT;
  // Accept
  return rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;

}

/**
 * 
 * @param goal_handle 
 * @return return 
 */
rclcpp_action::CancelResponse anchoring_process_impl::update_state_cancel(
    const std::shared_ptr<
        rclcpp_action::ServerGoalHandle<
            anchoring_process_interfaces::action::UpdateState>> /*in*/goal_handle) {

  RCLCPP_INFO(this->get_logger(), "[update_state] Got cancel request for goal %s.", rclcpp_action::to_string(goal_handle->get_goal_id()).c_str());
  return rclcpp_action::CancelResponse::ACCEPT;

}

/**
 * 
 * @param goal_handle 
 */
void anchoring_process_impl::update_state_accepted(
    const std::shared_ptr<
        rclcpp_action::ServerGoalHandle<
            anchoring_process_interfaces::action::UpdateState>> /*in*/goal_handle) {

    const auto goal = goal_handle->get_goal();

    RCLCPP_INFO(this->get_logger(), "[update_state] Executing request for domain %s (request uuid %s)", goal->knowledge_domain.c_str(), rclcpp_action::to_string(goal_handle->get_goal_id()).c_str());

    auto result = std::make_shared<anchoring_process_interfaces::action::UpdateState::Result>();
    result->result.success = false;
    result->result.message = "";

    // Get the database name for the domain
    std::string dbname = databases_.find(goal->knowledge_domain)->second;

    std::string q = "match $r (asset: $a, twin: $t) isa has_id; "
                    "$a has id $aid; $t has dt-id $did; $t has platform-name $pn; "
                    "get $a, $aid, $did, $pn;";

    auto cm_configs = TypeDBClient::read_data(q, driver_, dbname);
    RCLCPP_INFO(this->get_logger(), "[update_state] size of configs vector: %ld.", cm_configs.size());

    // convert concept map configs to data struct
    std::vector<DTConfig> configs;
    for (TypeDB::ConceptMap& map : cm_configs) {
        DTConfig c;
        c.cls              = map.get("a")->asEntity()->getType()->getLabel();
        c.parentInstanceId = map.get("aid")->asAttribute()->getValue()->asString();
        c.dtId             = map.get("did")->asAttribute()->getValue()->asString();
        c.platform         = map.get("pn")->asAttribute()->getValue()->asString();
        configs.push_back(std::move(c));
    }

    // Print results (log)
    for (auto& c : configs)
      RCLCPP_INFO(this->get_logger(), "[update_state] Type=%s, Instance=%s, DT_ID=%s, Platform=%s.",
            c.cls.c_str(), c.parentInstanceId.c_str(), c.dtId.c_str(), c.platform.c_str());

    // Process each DT_Config entry (Step 4)
    const std::string dtFile = goal->instances;
    for (auto &c : configs)
    {
      try
      {
        // Fetch the DT JSON
        json dt_data = DTSimulator::fetchDTData(c.dtId, dtFile);
        // entity-specific queries
        std::vector<std::string> queries;
        std::vector<std::string> cls_queries = managers_[c.cls]->generateUpdateStateQueries(c.parentInstanceId, dt_data);
        queries.reserve(queries.size() + cls_queries.size());
        queries.insert(queries.end(), cls_queries.begin(), cls_queries.end());

        // - write
        TypeDBClient::update_data(queries, driver_, dbname);

        RCLCPP_INFO(this->get_logger(), "[update_state] Anchored data for %s.", c.parentInstanceId.c_str());
      }
      catch (const std::exception &e)
      {
        // terminate action (failure!)
        result->result.message = std::string(e.what());
        RCLCPP_FATAL(this->get_logger(), "[update_state] Error for dt-id=%s : %s!", c.dtId.c_str(), e.what());
        goal_handle->abort(result);
        return;
      }
    }

    // terminate action (success!)
    RCLCPP_INFO(this->get_logger(), "[update_state] Request for goal %s executed successfully.", rclcpp_action::to_string(goal_handle->get_goal_id()).c_str());
    result->result.success = true;
    goal_handle->succeed(result);
}

} // of namespace anchoring_process_def

/************************************************************
 End of anchoring_process_impl class body
 ************************************************************/
